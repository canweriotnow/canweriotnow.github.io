<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web | Practical Elegance]]></title>
  <link href="http://decomplecting.org/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://decomplecting.org/"/>
  <updated>2012-10-31T15:38:37-04:00</updated>
  <id>http://decomplecting.org/</id>
  <author>
    <name><![CDATA[Jason Lewis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Static Is Beautiful]]></title>
    <link href="http://decomplecting.org/blog/2012/07/04/static-is-beautiful/"/>
    <updated>2012-07-04T23:21:00-04:00</updated>
    <id>http://decomplecting.org/blog/2012/07/04/static-is-beautiful</id>
    <content type="html"><![CDATA[<p>I want to return to the core sfocus of this blog, elegance and simplicity in technology, but in kind of a meta way.</p>

<p>One trend that seems to be popping up again and again is the move away from over-featured and unmanageable content management systems (I'm looking at you, <a href="http://wordpress.org/">Wordpress</a>), and toward static site generators.</p>

<p>This blog, for instance, is generated from <a href="http://daringfireball.net/projects/markdown/">Markdown</a> files by <a href="http://octopress.org/">Octopress</a>. More on Octopress later, but I want to survey the trend a bit.</p>

<p>This post was prompted by one of the auto-tweets by <a href="https://twitter.com/rubygems">@rubygems</a>, about yet another static site generation tool called <a href="https://rubygems.org/gems/gumdrop">gumdrop</a>. I've been playing with a few different static site generation tools, so first I'd like to survey a few examples, and then I'll talk about why I think they matter.</p>

<!-- more -->


<h3>Jekyll</h3>

<p><a href="https://github.com/mojombo/jekyll">Jekyll</a> is kinda the all-father of the current crop of static site generators. Created by <a href="http://tom.preston-werner.com/">Tom Preston-Werner</a> of <a href="https://github.com">GitHub</a>, it powers many, many <a href="http://pages.github.com/">GitHub Pages</a> sites, and is pretty much pure awesomesauce. It's very bare bones, but that's what allows for such enormous flexibility. It's also what allows Jekyll to serve as the backbone of something like Octopress.</p>

<h3>Octopress</h3>

<p><a href="http://octopress.org">Octopress</a> is my current favorite, as I use it all the time to power <a href="http://decomplecting.org">this blog</a>. Octopress wraps Jekyll with a bunch of templating goodness, which you can easily customize to your heart's content.</p>

<p>One of the best thngs about Octopress, however, is its plugin system. Not only does it come pre-loaded with some snazzy plugins for the <a href="https://github.com/Shopify/liquid">Liquid</a> template language, but it makes it easy to extend with your own clever hacks.</p>

<p>Better yet, as it's a hacker-oriented blogging engine, it makes it dead simple to set up common widgets and services, from a GitHub repo listing to Google Analytics, just by editing <code>_config.yml</code>, the global configuration file.</p>

<p>Best of all, new post generation, testing, building, and deploying are all handled by <code>rake</code> tasks, and deployment via GitHub Pages, <a href="http://heroku.com">Heroku</a>, and <code>rsync</code> are easy as hell to configure.</p>

<h3>Middleman</h3>

<p><a href="http://middlemanapp.com/">Middleman</a> is a newer static site generation tool, with all the sauce. You can template/style/script with Haml, Slim, Sass, Compass, CoffeeScript, and I'm sure others. It comes with <a href="http://html5boilerplate.com/">HTML5 Boilerplate</a> baked in (if you're not using this, you probably should be), and it's built around <a href="http://www.sinatrarb.com">Sinatra</a>.</p>

<p>I haven't deployed Middleman anywhere yet, as the only static-content site I'm running right now is this blog, but it's definitely on the radar for the second I want to branch out from blogging with this domain (or any of my others).</p>

<h3>Gumdrop</h3>

<p>I know way less about <a href="https://github.com/darthapo/gumdrop">gumdrop</a> than about the other static site generators out there... but the <a href="https://github.com/darthapo/gumdrop/wiki/Sites-Using-Gumdrop">sites powered by gumdrop</a> are nothing if not impressive. Gumdrop bills itself as "The sweet 'n simple cms/prototyping tool for creating static html websites and webapps."</p>

<p>I can't argue. The generation looks slick and simple, but also powerfully configurable, thanks to the awesomesauce of Ruby blocks.</p>

<p>I'll definitely be playing with this in my <em>copious</em> spare time.</p>

<h2>Why Static Site Generation Matters</h2>

<p>It's pretty simple, actually. It all comes down to Wordpress.</p>

<blockquote class="twitter-tweet tw-align-center"><p>And there's only one thing worse in my eyes than PHP, and that's Wordpress PHP <a href="http://t.co/C40EfvOD" title="http://buff.ly/LkQIWH">buff.ly/LkQIWH</a></p>&mdash; Michael Robinson (@pagesofinterest) <a href="https://twitter.com/pagesofinterest/status/220254607849426946" data-datetime="2012-07-03T20:36:05+00:00">July 3, 2012</a></blockquote>


<script src="http://decomplecting.org//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>We all <em>know</em> PHP is <a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">a terrible excuse for a programming language</a>, and also that the blogging platform wars, until recently, came down to only WordPress vs. <a href="http://www.blogger.com">Blogger</a>. Of course, <a href="http://tumblr.com">Tumblr</a> and <a href="http://postero.us">Postero.us</a> have breathed new life into a limited set of choices. But unless you wanted only the most basic features a hosted platform (everything but WordPress, honestly) provided, you'd need to settle on WordPress, because as an open-source platform, it had this <del>great</del> almost usable ecosystems of custom plugins. And somehow, the blogging community convinced ourselves we <em>needed</em> this plugin marketplace.</p>

<p>Now, don't get me wrong. As economies go, the WordPress plugin market has proved a lucrative environment for many freelance PHP developers I know. Mind you, because they were writing WordPress PHP 8-10 hours a day, their mental states ranged between suicidal and psychotic... we all have our limits.</p>

<p>The need for a sane solution to this problem is, I think, what led to the development of blogging engines like <a href="http://fdv.github.com/typo/">typo</a>.</p>

<p>And, I think, the attempt to build a new, saner, databased-backed, comprehensive, blog-aware CMS system learned that a databased-backed, comprehensive, blog-aware CMS system is a whole bunch of <a href="http://en.wikipedia.org/wiki/You_ain't_gonna_need_it">YAGNI</a> features rolled up in a big, painful bundle.</p>

<p>Why not just generate your blog posts when you write them? Why not just use Javascript for whatever dynamic widgets you need? It's all HTML in the end, right?</p>

<p>Possibly, some of the impetus for this is the arguable feature of PHP that, unlike Ruby on Rails (at that time), PHP was dirt-cheap to deploy/host, whereas RoR required either a VPS or a pricey Engine Yard instance. This was, after all, before the days of free-ish <a href="http://heroku.com">Heroku</a> instances for low-traffic apps. And, even then, what if your blog became insanely popular? It could get pricey pretty quickly, whereas you could have a medium-traffic WordPress blog on some PHP host for, what, US$3.00 a month?</p>

<p>So economics and technology collide. We find ourselves searching for a simpler solution, using better tools and easier hosting. For static sites, you can have free hosting on GitHub Pages just by pushing a site to the your-username.github.com repo under your GitHub account. For that matter, you can host a static site (virtually) for free damn near anywhere you like.</p>

<p>So <em>why</em> were we spending all this time and effort building out complicated content management systems, just to spend unnecessary time and money on a blog?</p>

<p>Static site generators are the answer. Spend your coding time actually coding for web <em>applications,</em> not for (mostly) static content. Sure, the learning curve is higher to use Octopress vs. WordPress. But I think I've <a href="/blog/2012/06/06/hackers-need-our-own-everything/">addressed this issue</a>.</p>

<p>Before you build another CMS, or decide to use WordPress because it's the "obvious choice," ask your self this: What are the features I <em>actually</em> need? Can these be met by <code>%w{Jekyll Octopress Middleman Gumdrop other-static-generator}</code>? Then do what makes sense. Needlessly complicating your online life is not a virtue.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hypermedia APIs: The New Wild West?]]></title>
    <link href="http://decomplecting.org/blog/2012/05/30/hypermedia-apis-the-new-wild-west/"/>
    <updated>2012-05-30T13:26:00-04:00</updated>
    <id>http://decomplecting.org/blog/2012/05/30/hypermedia-apis-the-new-wild-west</id>
    <content type="html"><![CDATA[<p>Two of the best presentations at RailsConf this year, <strong>Designing Hypermedia APIs</strong> by <a href="http://steveklabnik.com/">Steve Klabnik</a> and <strong>Rails: The Next Five Years</strong> by <a href="http://yehudakatz.com/">Yehuda Katz</a> were related to the topic of hypermedia APIs. The video of Steve's talk isn't up on Confreaks yet, but the slides are <a href="http://steveklabnik.github.com/hypermedia-presentation/#1">here</a>. I'll embed Yehuda's talk right here:</p>

<iframe width="560" height="315" src="http://www.youtube-nocookie.com/embed/UlMpIHH1K5s" frameborder="0" allowfullscreen></iframe>


<p>The two big takeaways from these talks (for me, at least):</p>

<ol>
<li>We've come a long way in designing in implementing APIs. But now we're to the "hard part": Going from REST to true hypermedia.</li>
<li>Rails is really, really good at creating de facto standards via "convention over configuration." But we don't go far enough, and that's where we shoot ourselves in the foot (think ActiveResource).</li>
</ol>


<h3>Why don't you REST for a while?</h3>

<p>I know, it's stressful figuring this stuff out.  Rails going all RESTful was a big help when it came to creating uniform interfaces for our applications. HTML, XML, JSON... you could have it your way, right away. But going from RESTful resources to true hypermedia APIs is an even bigger leap forward than the move to REST, and that transition also needs to be planned and implemented carefully and correctly.</p>

<p><code>as_json</code> will only get you so far. Yes, it will represent the resource in a way that is eminently consumable by a client application, whether that's Javascript in the browser, a mobile app, or curl. But your client still needs to know <em>far</em> too much about the structure of the resources on your server. That's tight coupling, which we all know is evil. It's even evilly-tight from a REST standpoint; if the client has to know <em>anything</em> about server-side resources, you're breaking the encapsulation layer between resources and the representation of those resources, which is what REST is all about, right?</p>

<p>So what is to be done?</p>

<!-- more -->


<h3>HATEOAS</h3>

<p>Yeah, there it is. <strong>Hypermedia As The Engine Of Application State.</strong> That last layer of REST that we'd rather not think about, much less try to implement.</p>

<p>We know better, but we do all sorts of crazy things in order <em>not</em> to do it right. One of the most common sins (I'm guilty myself) is embedding nested resources inside of the requested resource.</p>

<p>What's wrong with embedding, for instance, comments in the JSON representation of an article?</p>

<p>If nothing else, when I request an article, I'm requesting a specific representation of a specific resource. I don't necessarily <em>want</em> all of its child resources or other associations. I should <em>know</em> about them, but not forced to accept them.</p>

<p>Furthermore,</p>

<p>I really like the example Steve used of implementing a <code>links</code> array in the returned object:</p>

<p>```json Sample response http://steveklabnik.github.com/hypermedia-presentation/#47</p>

<p>request("http://w3clove.com/api/",
  "application/vnd.w3clove.validation+json")</p>

<h1>=></h1>

<p>{
  "links":[
  {"rel":"website-form", "href":"..."},
  {"rel":"sitemap-form", "href":"..."}
  ]
}</p>

<p>```</p>

<p>What's especially interesting here is the Content-type: <code>application/vnd.w3clove.validation+json</code>. That was another big takeaway: I was unaware of the <code>vnd</code> prefix for defining your own content-types, rather than waiting (and waiting, and waiting...) for the W3C to define a standard.</p>

<p><img class="float-right" src="http://imgs.xkcd.com/comics/standards.png"></p>

<p>Please don't take that as encouragement to go create 2<sup>10</sup> new content-types all willy nilly. Use something that exists, preferably an accepted standard, unless there <em>really, really</em> isn't an acceptable standard for your use case.</p>

<p>In that scenario, there's nothing wrong with defining a content-type that meets your needs, provided you thoroughly spec it and adhere to the spec.</p>

<h3>as_json is not the answer</h3>

<p>I want to go a little further into why links > nested resources.</p>

<p>Let's say you have an <code>Article</code> class, which <code>has_many :comments</code> and <code>has_and_belongs_to_many :tags</code> You might think it's a good idea to do this:</p>

<p>```ruby article.rb</p>

<p>class Article &lt; ActiveRecord::Base</p>

<p>  has_many :comments
  has_and_belongs_to_many :tags
  belongs_to :user</p>

<p>  def as_json(options={})</p>

<pre><code>options[:include] = {:comments =&gt; [], :tags =&gt; []}
options[:except] = :user_id
return super(options)
</code></pre>

<p>  end</p>

<p>end</p>

<p>```</p>

<p>It's not necessarily terrible, but it's not optimal. Normally you might get back:</p>

<p>```json</p>

<p>{
  article: {</p>

<pre><code>title: "First Post!",
body: "Chillwave fixie food truck vinyl. Squid cred +1, cardigan sustainable before they sold out wayfarers twee synth. Retro cliche 3 wolf moon banh mi, put a bird on it hella american apparel sriracha ennui artisan beard. Small batch four loko cardigan, umami stumptown keffiyeh cray street art etsy. Whatever high life synth godard 3 wolf moon, brunch PBR hella banh mi gluten-free vegan next level mustache stumptown lo-fi. Ethnic photo booth pork belly wayfarers, cardigan blog etsy portland mumblecore single-origin coffee post-ironic shoreditch. +1 typewriter sriracha authentic artisan master cleanse, bushwick freegan keytar."
comments: [
  {
    id: 1,
    body: "Dude!"
  }
],
tags: [
  {
    id:3,
    name: "hipster-crap"
  }
]
</code></pre>

<p>  }
}</p>

<p>```</p>

<p>This might be okay until you end up with hundreds of long-winded comments about where to find the best kefir in Portland. And what if your client wants to follow the tags to find similar articles? Sure, they can assume you're following rails conventions for URIs and try to get "http://example.org/tags/3", but there's no guarantee that's what you're doing, and it's expecting too much of the client. What if you want to find more by the same author? you've decided in advance your clients don't need to see the user_id.</p>

<p>Worse, you're now eager-loading all of your associations, which, while preferable to a risk of n+1 queries, does mean you're banging on your database harder.</p>

<p>There's another added benefit: if <em>all</em> a resource needs to know about its associations is where to find them, you've just loosened the coupling between those classes. It's a Good Thing.</p>

<p>It occurred to me that there's an (imperfect) metaphor for this: pass-by-value vs. pass-by-reference. Rather than copying the value from the server to the client, you pass a reference where the value can be retrieved. Yes, I know this is closer to C pointers ("pass-by-value where the value is a reference") than than true pass-by-reference. Anyhow.</p>

<h3>Tradeoffs</h3>

<p>There are definitely some potential latency-induced pitfalls here. By leaving the task of requesting the appropriate representations of the appropriate resources to the client, we're buying decoupling and a reduction in unnecessary database activity at the potential cost of <em>many</em> more HTTP requests.</p>

<p>This might be true. But it just highlights a need that already existed: we really, really need to optimize HTTP. We need to use <a href="http://www.igvita.com/2011/10/04/optimizing-http-keep-alive-and-pipelining/">keep-alive and pipelining</a>, and we need to understand <a href="http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/">TCP slow-start</a>. Among other things.</p>

<h3>The Wild West</h3>

<p>Now, back to the title line. Hypermedia API design is kinda chaotic right now, with all sorts of possible solutions, from the clever and innovative to the completely brain-damaged.</p>

<p>One thing Rails has been pretty good at is pushing the envelope, gaining wide adoption of good ideas, and giving the other web frameworks something to aspire to/catch up with. We've seen this with MVC, REST, and now the asset pipeline. It is, to a large degree, the convention-over-configuration principle that drives this phenomenon, and in Yehuda's talk, he laments the state of ActiveResource, which is pretty useless for the most part, and (correctly, I think) blames the fact that we don't have a good convention for resource serialization, which ActiveResource could consume intelligently.</p>

<p>There are plenty of good options out there already; the <a href="https://github.com/apotonick/roar">roar</a> gem recently got support for the <a href="http://stateless.co/hal_specification.html">JSON-HAL</a> content-type, which I think is a great approach to HATEOAS, although not perfect.</p>

<p>The <a href="https://github.com/jcasimir/draper">draper</a> has HATEOAS helpers listed as a TODO, and that'll be great. If you need decorators, you should definitely be using draper. If you don't think you need decorators, you're probably wrong.</p>

<p>Ultimately, however, I think for Rails applications to implement true hypermedia APIs in a consistent fashion, something needs to make it into Rails core that's better than the current serialization methods in <code>ActiveRecord::Base</code>. So I'm <strong>really, really</strong> happy about <code>ActiveModel::Serializers</code>. I think it points to the Right Thing. Please try it out, and use it in your apps. It's not in Rails core yet, but if we all start using it, there's a better chance of it being included in Rails 4. And that would be really, really cool. Better yet, you can fork and contribute to it (yeah, it's on my list to do... someday).</p>

<p>The "wild west" can be exciting, but it's not where most of us want to live. Building sane infrastructure allows us to work at higher levels of abstraction, and that's where the <em>real</em> fun and excitement lives, right?</p>
]]></content>
  </entry>
  
</feed>
