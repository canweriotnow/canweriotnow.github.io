<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | Practical Elegance]]></title>
  <link href="http://decomplecting.org/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://decomplecting.org/"/>
  <updated>2013-05-15T00:07:18-04:00</updated>
  <id>http://decomplecting.org/</id>
  <author>
    <name><![CDATA[Jason Lewis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAM Authentication Beyond The Desktop]]></title>
    <link href="http://decomplecting.org/blog/2013/03/08/pam-authentication-beyond-the-desktop/"/>
    <updated>2013-03-08T20:11:00-05:00</updated>
    <id>http://decomplecting.org/blog/2013/03/08/pam-authentication-beyond-the-desktop</id>
    <content type="html"><![CDATA[<p>The Linux <a href="http://www.linux-pam.org/">PAM</a> (Pluggable Authentication Modules) architecture is one of the most wonderful (and most overlooked) features of the OS. Typically we only consider PAM as handling our console (or xdm/gdm etc. logins) on Linux, but it's useful for so much more.</p>

<h3>Web Authentication</h3>

<p>At work, we needed an authentication solution that allowed users to sign in with their ActiveDirectory credentials. Although the "official" solution was to use <a href="http://www.ca.com/us/secure-single-sign-on.aspx">SiteMinder</a> for web authentication against AD, we were working on a mobile application, and at the time the SiteMinder auth page was ugly, and had no mobile-optimized login page. The latter problem has since been rectified; now it has both an ugly desktop login and an ugly mobile login. In addition, we were using nginx, and SiteMinder was really only supported under IIS and Apache (and at the time, the latter was via Shibboleth. Ugh.), so without official SiteMinder support, or an nginx Shib plug-in, we were in a bit of a bind.</p>

<p>Around the same time, I was playing with Likewise Open (now known as <a href="http://www.powerbrokeropen.org/">PowerBroker Identity Services - Open Edition</a>) to bind my Linux workstation into AD. So it occurred to me: if a normal Linux PAM login can be authenticated against ActiveDirectory, why not a PAM login from a web application?</p>

<p>I know, I know, my first though should have been LDAP, right? For some unknown reason, LDAP was verboten at the time. The policy has since (apparently) been reversed, but such is the ebb and flow of corporate politics. And so, in the grand tradition of one of the mothers of modern computer science (and one of my daughter's namesakes):</p>

<p><blockquote><p>If it's a good idea, go ahead and do it. It is much easier to apologize than it is to get permission.</p><footer><strong>Rear Admiral Dr. Grace Murray Hopper</strong></footer></blockquote></p>

<!--more-->


<p>My first obstacle was to figure out how to do this from Ruby. <a href="https://github.com/binarylogic/authlogic">Authlogic</a> is a decent authentication framework (Sure, Devise is newer, but there's nothing wrong with Authlogic). There's an <a href="https://github.com/jhu-idcs/authlogic_pam">authlogic_pam</a> plugin (link is to my updated version, original seems to be abandoned), so the main issue was updating the long-abandoned rpam gem to tie into PAM. So I created <a href="https://github.com/canweriotnow/rpam-ruby19">rpam-ruby19</a> to have a C extension compatible with Ruby ~>1.9.2. Once the server (all of our production servers are <a href="http://www.debian.org/releases/stable/">Debian 6 "Squeeze"</a>) was tied into AD, it was relatively trivial to create a login that used Authlogic to hit PAM (and thusly ActiveDirectory) for user authentication.</p>

<h3>But now everyone has a server login?</h3>

<p>No, not at all. Likewise/PBIS has a setting to change the login shell for <em>only</em> AD users; we simply changed their shell to <code>/bin/true</code>. Problem solved.</p>

<h3>And that forgiveness/permission thing?</h3>

<p>While we were in beta, we informally ran the auth scheme by the people directly responsible for such things. They actually thought it was pretty cool and innovative. Which just reinforces my dedication to the timeless wisdom of Dr. Hopper.</p>

<h3>And so...</h3>

<p>Since we implemented this auth scheme for our mobile app, we've continued to go with it; it's simple, elegant, and shields us from capturing (even hashed) credentials. We have two(-ish) new products launching this year using the same auth scheme. And we're still quite satisfied with the results.</p>

<h3>Caveats</h3>

<p>Over the past couple of months, I've been researching an <a href="https://github.com/canweriotnow/rpam-ruby19/issues/5">issue submitted on Github</a> documenting a problem authenticating local users other than the euid running the process. You can get the details from the link, but this is how PAM (or at least shadow passwords) are supposed to work. This isn't for authenticating local system accounts (at least not if you're using shadow passwords properly); you should only auth external accounts (LDAP, ActiveDirectory, maybe NIS+) through PAM for non-system-login applications.</p>

<h3>Future</h3>

<p>Since this has worked out so well with our Rails apps, I'm now working on a Clojure equivalent. There's a PAM integration library for Java called JPam, which I've started wrapping in a library called <a href="https://clojars.org/clj-pam">clj-pam</a>, available from Clojars. If you'd like to help, the source repo is located <a href="https://github.com/canweriotnow/clj-pam">here on Github</a>.</p>

<p>PAM is wonderfully extensible. It's also very configurable, and is worth leveraging whenever possible. Dig deeper. Linux has so many great little pieces we tend to overlook.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DCI: The Right Idea for The Wrong Paradigm]]></title>
    <link href="http://decomplecting.org/blog/2013/01/03/dci-the-right-idea-for-the-wrong-paradigm/"/>
    <updated>2013-01-03T01:10:00-05:00</updated>
    <id>http://decomplecting.org/blog/2013/01/03/dci-the-right-idea-for-the-wrong-paradigm</id>
    <content type="html"><![CDATA[<p>I've been following with great interest the recent debate over DCI vs. Concerns vs. Whatever in Ruby. The best take I've seen, however, is Tony Arcieri's recent post, <a href="http://tonyarcieri.com/dci-in-ruby-is-completely-broken">"DCI" in Ruby Is Compeltely Broken</a>.</p>

<p>Reading his post, it ocurred to me that what Rubyists are trying to do with <code>object.extend(Module)</code> is precisely what Lisp hackers have been doing for years with macros, but it's an ugly hack when applied in the wrong paradigm (or, at least, the wrong language).</p>

<p>Now, I was initially a big fan <em>conceptually</em> of DCI. It seemed intuitive, even familiar. And it helped that it was the brainchild of Trygve Reenskaug, the erstwhile inventor of MVC, possibly one of the most useful OOP patterns ever devised.</p>

<p>But the more familiar it seemed, the more difficult it seemed to implement properly, much less efficiently, even in the purest of modern OO languages, i.e., Ruby.</p>

<p>It wasn't until I tried to forget everything I knew about OOP that its familiarity became clear: this novel appropach to object-oriented design is embedded in the most natural thing in the world in the oldest of functional programming languages, Lisp.</p>

<p>Enter the macro. In Clojure, providing context to a function is straightforward using a macro, for instance, a database query (n.b., most of this is straight example code from <a href="http://en.wikibooks.org">wikibooks.org</a>).</p>

<p>```clojure Set up JDBC connection http://en.wikibooks.org/wiki/Clojure_Programming/Examples/JDBC_Examples#PostgreSQL
(use 'clojure.java.jdbc)</p>

<p>(let [db-host "localhost"</p>

<pre><code>  db-port 5432
  db-name "a_database"]
</code></pre>

<p>  (def db {:classname "org.postgresql.Driver" ; must be in classpath</p>

<pre><code>       :subprotocol "postgresql"
       :subname (str "//" db-host ":" db-port "/" db-name)
       ; Any additional keys are passed to the driver
       ; as driver-specific properties.
       :user "a_user"
       :password "secret"}))
</code></pre>

<p><code>``
This provides the context for the</code>with-connection` macro:</p>

<p>```clojure SELECT Statement http://en.wikibooks.org/wiki/Clojure_Programming/Examples/JDBC_Examples#SELECT</p>

<p>(with-connection db
   (with-query-results rs ["select * from blogs"]</p>

<pre><code> ; rs will be a sequence of maps, 
 ; one for each record in the result set. 
 (dorun (map #(println (:title %)) rs))))
</code></pre>

<p>```</p>

<p>I'm using the simplest of (admittedly cribbed) examples here for the sake of demonstration, but right away here, we've got the D and C of DCI - Data and Context. As for interaction... we could easily conceive of a <code>with-role</code> macro which determines the interaction of the database connection and the actual application of the <code>with-connection</code> macro, whether it invokes a SELECT, CREATE, UPDATE, or DELETE statement.</p>

<p>In a Lisp, this level of composition is completely <em>natural,</em> is my point. In a language like Ruby (which despite having much of the Lisp nature, is OO to its core), and especially in a framework like Rails, with its cargo-cult Design Pattern-worshipping user base (I'm going to take some shit for that one, but accept that I'm exaggerating and flame with that in mind), is it any surprise that a pattern that makes <em>total sense</em> in an FP context is going to be a hot controversy in an OOP context?</p>

<p>I agree with Tony's post that "DCI" in Rails is totally broken. But that's because, IMHO, DCI isn't the best pattern for OOP. Yeah, Ruby has <em>lots</em> of functional features, but maybe we need to rethink how we're doing this DCI stuff (or Concerns, or whatever), on the basis that messing with inheritance and the class hierarchy is the <em>wrong thing,</em> and perhaps we should be creatively exploring the use of blocks and lambdas and Ruby's other functional constructs.</p>

<p>I'm not offering any solutions here, but I'm hoping I can contribute to the conversation. Step away from the mixins, away from the class hierarchy, away from the object model. Maybe take another read of Design Patterns and see if DCI is another hot YAGNI thing. I don't know yet. I just know it reminds me of how things are AWESOME in a whole other paradigm that doesn't necessarily apply to your Rails app.</p>

<p>As a caveat, I should say that I haven't really tried to use this DCI mojo in a production application, although I have played with different ideas about it Just For Fun&copy;. If you think I'm wrong, or have the whole thing arse-about-face, I'd be happy to discuss it in the comments.</p>
]]></content>
  </entry>
  
</feed>
